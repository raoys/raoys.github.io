<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jason Rao&#39;s Blog</title>
  
  <subtitle>态度决定一切，细节决定成败</subtitle>
  <link href="https://raoys.github.io/atom.xml" rel="self"/>
  
  <link href="https://raoys.github.io/"/>
  <updated>2025-01-14T03:16:09.139Z</updated>
  <id>https://raoys.github.io/</id>
  
  <author>
    <name>Jason Rao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一文搞懂frp内网穿透并搭建配置使用</title>
    <link href="https://raoys.github.io/2022/08/26/it-other-frp-202208261113.html"/>
    <id>https://raoys.github.io/2022/08/26/it-other-frp-202208261113.html</id>
    <published>2022-08-26T03:13:11.000Z</published>
    <updated>2025-01-14T03:16:09.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>一文搞懂frp内网穿透并搭建配置使用</strong> </p><pre class="line-numbers language-none"><code class="language-none">简介： 一文搞懂frp内网穿透并搭建配置使用，Windows、Mac电脑远程链接！ frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="frp-是什么"><a href="#frp-是什么" class="headerlink" title="frp 是什么"></a>frp 是什么</h4><pre class="line-numbers language-none"><code class="language-none">frp 是一个专注于内网穿透的高性能的反向代理应用，支持 TCP、UDP、HTTP、HTTPS 等多种协议。可以将内网服务以安全、便捷的方式通过具有公网 IP 节点的中转暴露到公网。有了内网穿透你能干什么？远程访问内网的 http/https 服务远程桌面(Windows/Mac)远程文件、 SSH小程序开发...有了内网穿透在外访问家里的电脑、NAS、树莓派、摄像头等网络设备或远程控制，那都不是事儿~<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><pre class="line-numbers language-none"><code class="language-none">官方项目地址：https://github.com/fatedier/frp以下命令请在服务器中执行下载 wget https://github.com/fatedier/frp/releases/download/v0.38.0/frp_0.38.0_linux_amd64.tar.gz解压tar -xvf frp_0.38.0_linux_amd64.tar.gz 移动至/usr/localmkdir /usr/local/frpmv frp_0.38.0_linux_amd64/* /usr/local/frp/文件说明frps.ini: 服务端配置文件frps: 服务端软件frpc.ini: 客户端配置文件frpc: 客户端软件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置systemctl来控制，服务端运行"><a href="#配置systemctl来控制，服务端运行" class="headerlink" title="配置systemctl来控制，服务端运行"></a>配置systemctl来控制，服务端运行</h4><pre class="line-numbers language-none"><code class="language-none">vim新建文件并写入配置内容vim /usr/lib/systemd/system/frp.service写入以下内容，注意上文移动放置的路径和此处有关。这里是启动的服务端。[Unit]Description=The nginx HTTP and reverse proxy serverAfter=network.target remote-fs.target nss-lookup.target[Service]Type=simpleExecStart=/usr/local/frp/frps -c /usr/local/frp/frps.iniKillSignal=SIGQUITTimeoutStopSec=5KillMode=processPrivateTmp=trueStandardOutput=syslogStandardError=inherit[Install]WantedBy=multi-user.target重新加载服务的配置文件systemctl daemon-reload现在就可以用 systemctl 套装来控制 frp 了。启动/停止/重启，查看状态，设置开机自启/关闭开机自启systemctl start frpsystemctl stop frpsystemctl restart frpsystemctl status frpsystemctl enable frpsystemctl disable frp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="配置和使用"><a href="#配置和使用" class="headerlink" title="配置和使用"></a>配置和使用</h4><p>服务端</p><pre class="line-numbers language-none"><code class="language-none">frps.ini配置：[common] #必须设置bind_port = 7000 #是自己设定的frp服务端端口vhost_http_port = 80 #是自己设定的http访问端口token = 123  #核实身份用，加了更安全[ssh] #ssh反向代理(不是必须设置)listen_port = 6000 是自己设定的ssh访问端口[web] #http反向代理[]里的内容可以自己设定，但是客户端和服务端必须要对应(如[aaa],[bbb])；type = http #为服务类型，可以设为http,httpscustom_domains = test1.a.com #为要映射的域名，记得域名的A记录要解析到外网主机的IP。[web2] #同上(可设置多个)示例[common]bind_port = 7000vhost_http_port = 80[ssh]listen_port = 6000[web]type = httpcustom_domains = test1.a.com[web2]type = httpcustom_domains = test2.a.commy eg:[common]bind_port = 8888vhost_http_port = 8080 启动./frps -c ./frps.ini# 后台启动nohup ./frps -c ./frps.ini &amp;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>客户端</p><pre class="line-numbers language-none"><code class="language-none">frpc.ini配置：[common]server_addr = 远程frp服务器ipserver_port = 远程frp服务器端口token = 远程frp服务器token[http]type = httplocal_ip = 127.0.0.1local_port = 本地端口号remote_port = 远程frp服务器的http服务端口号custom_domains = 自定义配置的域名subdomain = 匹配服务端配置的subdomain_host示例：[common]server_addr = xx.xx.xx.xxserver_port = 7000token = 123[web] type = httpcustom_domains = xx.xx.xx.xxlocal_ip = 127.0.0.1local_port = 8080custom_domains = xxx.xxx.xxxsubdomain = k2pmy eg:[common]server_addr = www.mydomains.cnserver_port = 8888# 连接内网SSH[ssh] type = tcplocal_ip 127.0.0.1local_port 22remote_port 222# 访问内网http/https服务[web]type = httplocal_port = 80custom_domains = frp.mydomains.cn启动./frpc -c ./frpc.ini# 后台启动nohup ./frpc -c ./frpc.ini &amp;运行服务后访问 custom_domains:vhost_http_port示例：http://123.123.123.123 80可以省略<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>参考文章：<a href="https://developer.aliyun.com/article/853534?spm=ding_open_doc.document.0.0.14bc481bUUxa1q">https://developer.aliyun.com/article/853534?spm=ding_open_doc.document.0.0.14bc481bUUxa1q</a><br>参考博客：<a href="https://www.cnblogs.com/chywx/p/10939966.html">https://www.cnblogs.com/chywx/p/10939966.html</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;一文搞懂frp内网穿透并搭建配置使用&lt;/strong&gt; &lt;/p&gt;
&lt;pre class=&quot;line-numbers language-none&quot;&gt;&lt;code class=&quot;language-none&quot;&gt;简介： 一文搞懂frp内网穿透并搭建配置使用，Windo</summary>
      
    
    
    
    <category term="内网穿透" scheme="https://raoys.github.io/categories/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
    
    <category term="FRP" scheme="https://raoys.github.io/tags/FRP/"/>
    
    <category term="内网穿透" scheme="https://raoys.github.io/tags/%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
    
  </entry>
  
  <entry>
    <title>npm配置淘宝镜像远程仓库</title>
    <link href="https://raoys.github.io/2022/08/24/it-nodejs-202208241710.html"/>
    <id>https://raoys.github.io/2022/08/24/it-nodejs-202208241710.html</id>
    <published>2022-08-24T09:10:22.000Z</published>
    <updated>2025-01-14T03:16:09.138Z</updated>
    
    <content type="html"><![CDATA[<p><strong>npm配置淘宝镜像远程仓库</strong> </p><h4 id="第1步：淘宝镜像链接获取："><a href="#第1步：淘宝镜像链接获取：" class="headerlink" title="第1步：淘宝镜像链接获取："></a>第1步：淘宝镜像链接获取：</h4><pre class="line-numbers language-none"><code class="language-none">https://registry.npmmirror.comhttp://npm.taobao.org和 http://registry.npm.taobao.org 将在 2022.06.30 号正式下线和停止 DNS 解析。新域名为 npmmirror.com, 相关服务域名切换规则请参考：http://npm.taobao.org =&gt; http://npmmirror.comhttp://registry.npm.taobao.org =&gt; http://registry.npmmirror.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第2步：执行配置指令："><a href="#第2步：执行配置指令：" class="headerlink" title="第2步：执行配置指令："></a>第2步：执行配置指令：</h4> <pre class="line-numbers language-none"><code class="language-none">npm config set registry https://registry.npmmirror.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第3步：查看配置："><a href="#第3步：查看配置：" class="headerlink" title="第3步：查看配置："></a>第3步：查看配置：</h4> <pre class="line-numbers language-none"><code class="language-none">npm config get registry<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第4步：如果需要解除镜像并恢复到官方源，请执行以下命令："><a href="#第4步：如果需要解除镜像并恢复到官方源，请执行以下命令：" class="headerlink" title="第4步：如果需要解除镜像并恢复到官方源，请执行以下命令："></a>第4步：如果需要解除镜像并恢复到官方源，请执行以下命令：</h4> <pre class="line-numbers language-none"><code class="language-none">npm config set registry https://registry.npmjs.org<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;npm配置淘宝镜像远程仓库&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;第1步：淘宝镜像链接获取：&quot;&gt;&lt;a href=&quot;#第1步：淘宝镜像链接获取：&quot; class=&quot;headerlink&quot; title=&quot;第1步：淘宝镜像链接获取：&quot;&gt;&lt;/a&gt;第1步：淘宝镜像</summary>
      
    
    
    
    <category term="nodejs" scheme="https://raoys.github.io/categories/nodejs/"/>
    
    
    <category term="npm" scheme="https://raoys.github.io/tags/npm/"/>
    
    <category term="前端" scheme="https://raoys.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
    <category term="nodejs" scheme="https://raoys.github.io/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Docker Desktop搭建MySQL方法</title>
    <link href="https://raoys.github.io/2022/08/24/it-docker-202208241006.html"/>
    <id>https://raoys.github.io/2022/08/24/it-docker-202208241006.html</id>
    <published>2022-08-24T02:06:22.000Z</published>
    <updated>2025-01-14T03:16:09.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Docker Desktop搭建MySQL简单运行环境</strong> </p><h4 id="第1步：拉取mysql镜像："><a href="#第1步：拉取mysql镜像：" class="headerlink" title="第1步：拉取mysql镜像："></a>第1步：拉取mysql镜像：</h4><pre class="line-numbers language-none"><code class="language-none">如下命令：docker pull mysql:5.7.39<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第2步：在本地某个位置创建以下内容："><a href="#第2步：在本地某个位置创建以下内容：" class="headerlink" title="第2步：在本地某个位置创建以下内容："></a>第2步：在本地某个位置创建以下内容：</h4> <pre class="line-numbers language-none"><code class="language-none">mkdir D:\docker\mysql\logsmkdir D:\docker\mysql\datamkdir D:\docker\mysql\conf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="第3步：启动MySQL命令："><a href="#第3步：启动MySQL命令：" class="headerlink" title="第3步：启动MySQL命令："></a>第3步：启动MySQL命令：</h4> <pre class="line-numbers language-none"><code class="language-none"> docker run -p 3306:3306 --name mysql -v D:\docker\mysql\logs:/var/log/mysql -v D:\docker\mysql\data:/var/lib/mysql -v D:\docker\mysql\conf:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7.39下面是解释说明：docker run -p 6379:6379 # 映射本地6379端口到容器6379端口，前为本地端口--name mysql # 设置容器名称为mysql，方便以后使用docker ps进行管理-v D:\docker\mysql\logs:/var/log/mysql 关联本地D:\docker\mysql\logs 到容器/var/log/mysql目录，保存日志文件-v D:\docker\mysql\conf:/etc/mysql/conf.d # 关联本地D:\docker\mysql\conf文件到容器中/etc/mysql/conf.d，同样，前为本地-v D:\docker\mysql\data:/var/lib/mysql # 关联本地D:\docker\mysql\data到容器内/var/lib/mysql目录，此为存放MySQL数据的目录，且数据可持久化-e MYSQL_ROOT_PASSWORD=123456 # 设定默认root用户密码-d # 后台启动mysql:5.7.38 # 镜像名称:版本号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Docker Desktop搭建MySQL简单运行环境&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;第1步：拉取mysql镜像：&quot;&gt;&lt;a href=&quot;#第1步：拉取mysql镜像：&quot; class=&quot;headerlink&quot; title=&quot;第1步：拉取mysql</summary>
      
    
    
    
    <category term="容器" scheme="https://raoys.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="Docker" scheme="https://raoys.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker搭建Redis方法</title>
    <link href="https://raoys.github.io/2022/07/26/it-docker-202207262021.html"/>
    <id>https://raoys.github.io/2022/07/26/it-docker-202207262021.html</id>
    <published>2022-07-26T12:22:22.000Z</published>
    <updated>2025-01-14T03:16:09.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>搭建Redis简单运行环境</strong> </p><h4 id="第1步：拉取redis镜像："><a href="#第1步：拉取redis镜像：" class="headerlink" title="第1步：拉取redis镜像："></a>第1步：拉取redis镜像：</h4><pre class="line-numbers language-none"><code class="language-none">如下命令：docker pull redis<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第2步：在本地某个位置创建以下内容："><a href="#第2步：在本地某个位置创建以下内容：" class="headerlink" title="第2步：在本地某个位置创建以下内容："></a>第2步：在本地某个位置创建以下内容：</h4> <pre class="line-numbers language-none"><code class="language-none">mkdir -p /docker/redismkdir -p /docker/redis/datatouch /docker/redis/redis.conftouch /docker/redis/redis.bash<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第3步：编辑redis-conf："><a href="#第3步：编辑redis-conf：" class="headerlink" title="第3步：编辑redis.conf："></a>第3步：编辑redis.conf：</h4> <pre class="line-numbers language-none"><code class="language-none"># Redis配置文件# Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程daemonize no# 指定Redis监听端口，默认端口为6379port 6379# 绑定的主机地址，不要绑定容器的本地127.0.0.1地址，因为这样就无法在容器外部访问bind 0.0.0.0#需要密码则打开requirepass mima# 持久化appendonly yes<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第4步：编辑redis-bash："><a href="#第4步：编辑redis-bash：" class="headerlink" title="第4步：编辑redis.bash："></a>第4步：编辑redis.bash：</h4> <pre class="line-numbers language-none"><code class="language-none">docker run -p 6379:6379 --name redis -v /docker/redis/redis.conf:/etc/redis/redis.conf -v /docker/redis/data:/data -d redis redis-server /etc/redis/redis.conf 下面是解释说明：docker run redis # 从redis镜像运行容器-p 6379:6379 # 映射本地6379端口到容器6379端口，前为本地端口--name redis # 设置容器名称为redis，方便以后使用docker ps进行管理-v /docker/redis/redis.conf:/etc/redis/redis.conf # 关联本地/docker/redis/redis.conf文件到容器中/etc/redis/redis.conf，同样，前为本地-v /docker/redis/data:/data # 关联本地/docker/redis/data到容器内/data目录，此为存放redis数据的目录，为方便以后升级redis，而数据可以留存-d # 后台启动，使用此方式启动，则redis.conf中daemonize必须设置为no，否则会无法启动redis-server /etc/redis/redis.conf # 在容器内启动redis-server的命令，主要是为了加载配置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第5步：给予执行权限："><a href="#第5步：给予执行权限：" class="headerlink" title="第5步：给予执行权限："></a>第5步：给予执行权限：</h4> <pre class="line-numbers language-none"><code class="language-none">sudo chmod 777 /docker/redis/redis.bash<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="第6步：启动："><a href="#第6步：启动：" class="headerlink" title="第6步：启动："></a>第6步：启动：</h4> <pre class="line-numbers language-none"><code class="language-none">/docker/redis/redis.bash# 查看是否已启动docker ps# 如果无法启动或者docker ps中无对应内容，将bash中命令复制出来，删除-d参数启动，查看报错信息# 使用redis-cli或者rdm访问 localhost:6379# 如需访问容器，可使用docker exec -it redis bash# 或直接使用redis-cli访问容器内redisdocker exec -it redis redis-cli [-a mima]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;搭建Redis简单运行环境&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;第1步：拉取redis镜像：&quot;&gt;&lt;a href=&quot;#第1步：拉取redis镜像：&quot; class=&quot;headerlink&quot; title=&quot;第1步：拉取redis镜像：&quot;&gt;&lt;/a&gt;第1步：拉</summary>
      
    
    
    
    <category term="容器" scheme="https://raoys.github.io/categories/%E5%AE%B9%E5%99%A8/"/>
    
    
    <category term="Docker" scheme="https://raoys.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud使用Nginx代理、Gateway网关以后如何获取用户的真实IP</title>
    <link href="https://raoys.github.io/2022/03/01/it-java-202203011532.html"/>
    <id>https://raoys.github.io/2022/03/01/it-java-202203011532.html</id>
    <published>2022-03-01T07:32:13.000Z</published>
    <updated>2025-01-15T07:40:00.325Z</updated>
    
    <content type="html"><![CDATA[<p><strong>背景</strong></p><ul><li>微服务架构使用了Nginx代理转发、并且使用了SpringCloud的Gateway统一控制所有请求,并获取用户请求的IP地址。</li></ul><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><pre class="line-numbers language-none"><code class="language-none">1. Nginx设置  location / {       root /opt/xxx/xxx-auth;       index  index.html index.htm;       try_files $uri $uri/ /index.html;            # 获取用户请求ip      proxy_set_header Host $host;      proxy_set_header X-Real-IP $remote_addr;  #获取客户端真实IP      proxy_set_header REMOTE-HOST $remote_addr;  }    2. Gateway网关设置：@Component@Log4j2public class AuthenticationFilter implements GlobalFilter, Ordered {    /**     * 验证请求头是否带有Authentication     */    @Override    public Mono&lt;Void&gt; filter(ServerWebExchange exchange, GatewayFilterChain chain) {        ServerHttpRequest request = exchange.getRequest();        ServerHttpResponse response = exchange.getResponse();        String path = request.getPath().pathWithinApplication().value();        Optional.of(exchange.getRequest()).ifPresent(item -&gt; {            // 获取客户端IP地址            List&lt;String&gt; xForwardedFor = item.getHeaders().get("x-forwarded-for");            List&lt;String&gt; xRealIp = item.getHeaders().get("x-real-ip");            List&lt;String&gt; remoteHost = item.getHeaders().get("remote-host");            response.getHeaders().add("X-Forwarded-For", (xForwardedFor == null || xForwardedFor.isEmpty()) ? "" :                    xForwardedFor.get(0));            response.getHeaders().add("X-Real-IP", (xRealIp == null || xRealIp.isEmpty()) ? "" : xRealIp.get(0));            response.getHeaders().add("Remote-Host", (remoteHost == null || remoteHost.isEmpty()) ? "" :                    remoteHost.get(0));        });        //身份认证等等....                return chain.filter(exchange);    }    @Override    public int getOrder() {        return 0;    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过上述设置以后，我们就能正常在request请求头中获取IP信息，并可使用请求头透传到各服务模块内。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;背景&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;微服务架构使用了Nginx代理转发、并且使用了SpringCloud的Gateway统一控制所有请求,并获取用户请求的IP地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;解决方法&quot;&gt;&lt;a href=&quot;#解决方法</summary>
      
    
    
    
    <category term="后端" scheme="https://raoys.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="SpringCloud" scheme="https://raoys.github.io/tags/SpringCloud/"/>
    
    <category term="Gateway" scheme="https://raoys.github.io/tags/Gateway/"/>
    
    <category term="Nginx" scheme="https://raoys.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>HttpClient 如何设置请求接口等待时间</title>
    <link href="https://raoys.github.io/2021/10/03/it-java-202112111345.html"/>
    <id>https://raoys.github.io/2021/10/03/it-java-202112111345.html</id>
    <published>2021-10-02T23:15:22.000Z</published>
    <updated>2025-01-14T03:16:09.137Z</updated>
    
    <content type="html"><![CDATA[<p>我们在请求接口的时候容易出现请求超时的现象，出现这一问题的原因可能是接口确实挂了，也可能是接口还没有来的及响应，我们程序里面已经出现了请求超时的现象</p><h4 id="1、问题描述："><a href="#1、问题描述：" class="headerlink" title="1、问题描述："></a>1、问题描述：</h4><p>通常会出现以下的报错：</p><pre class="line-numbers language-none"><code class="language-none">java.net.SocketTimeoutException: Read timed outat java.net.SocketInputStream.socketRead0(SocketInputStream.java)at java.net.SocketInputStream.socketRead(SocketInputStream.java:116)at java.net.SocketInputStream.read(SocketInputStream.java:170)at java.net.SocketInputStream.read(SocketInputStream.java:141)at org.apache.http.impl.conn.LoggingInputStream.read(LoggingInputStream.java:84)at org.apache.http.impl.io.SessionInputBufferImpl.streamRead(SessionInputBufferImpl.java:137)at org.apache.http.impl.io.SessionInputBufferImpl.fillBuffer(SessionInputBufferImpl.java:153)at org.apache.http.impl.io.SessionInputBufferImpl.readLine(SessionInputBufferImpl.java:282)at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:138)at org.apache.http.impl.conn.DefaultHttpResponseParser.parseHead(DefaultHttpResponseParser.java:56)at org.apache.http.impl.io.AbstractMessageParser.parse(AbstractMessageParser.java:259)at org.apache.http.impl.DefaultBHttpClientConnection.receiveResponseHeader(DefaultBHttpClientConnection.java:163)at org.apache.http.impl.conn.CPoolProxy.receiveResponseHeader(CPoolProxy.java:165)at org.apache.http.protocol.HttpRequestExecutor.doReceiveResponse(HttpRequestExecutor.java:273)at org.apache.http.protocol.HttpRequestExecutor.execute(HttpRequestExecutor.java:125)at org.apache.http.impl.execchain.MainClientExec.execute(MainClientExec.java:272)at org.apache.http.impl.execchain.ProtocolExec.execute(ProtocolExec.java:185)at org.apache.http.impl.execchain.RetryExec.execute(RetryExec.java:89)at org.apache.http.impl.execchain.RedirectExec.execute(RedirectExec.java:110)at org.apache.http.impl.client.InternalHttpClient.doExecute(InternalHttpClient.java:185)at org.apache.http.impl.client.CloseableHttpClient.execute(CloseableHttpClient.java:83)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>结合接口日志的打印，我判断是第二种现象，就是接口还没有返回信息，我程序这边就出现了超时的报错。那么如何解决，我们只有增加接口的请求等待时间</p><h4 id="2、问题解决："><a href="#2、问题解决：" class="headerlink" title="2、问题解决："></a>2、问题解决：</h4><pre class="line-numbers language-none"><code class="language-none">private static Logger logger = LoggerFactory.getLogger(HttpUtil.class); public static String postGeneralUrl(String url, String contentType, String jsonParam, String encoding, int reSend) {logger.info("当前请求接口地址:{}",jsonParam.toString());// 声明返回结果String result = "";// 开始请求API接口时间long startTime = System.currentTimeMillis();// 请求API接口的响应时间long endTime = 0L;HttpEntity httpEntity = null;HttpResponse httpResponse = null;HttpClient httpClient = null;try { contentType = contentType == null ? "application/x-www-form-urlencoded" : contentType;// 创建连接httpClient = HttpClientFactory.getInstance().getHttpClient();// 设置请求头和报文HttpPost httpPost = HttpClientFactory.getInstance().httpPost(url);Header header = new BasicHeader("Accept-Encoding", null);RequestConfig requestConfig =  RequestConfig.custom().setSocketTimeout(20000).setConnectTimeout(20000).build();httpPost.setConfig(requestConfig);httpPost.addHeader(header);httpPost.addHeader("Content-Type", contentType);List&lt;NameValuePair&gt; list = new LinkedList&lt;&gt;();list.add(new BasicNameValuePair("params", jsonParam));// pageHelper放在body中传过去// 使用URL实体转换工具UrlEncodedFormEntity entityParam = new UrlEncodedFormEntity(list, "UTF-8"); // 使用 UrlEncodedFormEntity 来设置// // body,消息体内容httpPost.setEntity(entityParam);logger.info("请求{}接口的参数为{}", url, jsonParam);httpResponse = httpClient.execute(httpPost);httpEntity = httpResponse.getEntity();result = EntityUtils.toString(httpEntity);} catch (SocketTimeoutException es) {endTime = System.currentTimeMillis();result = "网络连接异常，请检查网络或者开票服务是否正常启动";logger.info("请求{}接口的响应报文内容为{},本次请求API接口的响应时间为:{}毫秒", url, result, (endTime - startTime));logger.error("请求{}接口出现异常", url, es);return result;} catch (Exception e) {logger.error("请求{}接口出现异常", url, e);} finally {try {EntityUtils.consume(httpEntity);} catch (IOException e) {e.printStackTrace();}}// 请求接口的响应时间endTime = System.currentTimeMillis(); logger.info("请求{}接口的响应报文内容为{},本次请求API接口的响应时间为:{}毫秒", url, result, (endTime - startTime));return result; }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中主要是这部分代码：</p><pre class="line-numbers language-none"><code class="language-none">   RequestConfig requestConfig =  RequestConfig.custom().setSocketTimeout(20000).setConnectTimeout(20000).build();httpPost.setConfig(requestConfig);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>当然这个设置和使用的 http.client 版本也有一定的关系，当前版本如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpcore --&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;&lt;artifactId&gt;httpcore&lt;/artifactId&gt;&lt;version&gt;4.4.10&lt;/version&gt;&lt;/dependency&gt; &lt;!-- https://mvnrepository.com/artifact/org.apache.httpcomponents/httpclient --&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.httpcomponents&lt;/groupId&gt;&lt;artifactId&gt;httpclient&lt;/artifactId&gt;&lt;version&gt;4.5.6&lt;/version&gt;&lt;exclusions&gt;&lt;exclusion&gt;&lt;groupId&gt;commons-codec&lt;/groupId&gt;&lt;artifactId&gt;commons-codec&lt;/artifactId&gt;&lt;/exclusion&gt;&lt;exclusion&gt;&lt;groupId&gt;commons-logging&lt;/groupId&gt;&lt;artifactId&gt;commons-logging&lt;/artifactId&gt;&lt;/exclusion&gt;&lt;/exclusions&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;我们在请求接口的时候容易出现请求超时的现象，出现这一问题的原因可能是接口确实挂了，也可能是接口还没有来的及响应，我们程序里面已经出现了请求超时的现象&lt;/p&gt;
&lt;h4 id=&quot;1、问题描述：&quot;&gt;&lt;a href=&quot;#1、问题描述：&quot; class=&quot;headerlink&quot; tit</summary>
      
    
    
    
    <category term="后端" scheme="https://raoys.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="JAVA" scheme="https://raoys.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>如何让Python pip使用国内镜像体验飞一样的速度</title>
    <link href="https://raoys.github.io/2018/09/01/it-python-01.html"/>
    <id>https://raoys.github.io/2018/09/01/it-python-01.html</id>
    <published>2018-09-01T11:25:49.000Z</published>
    <updated>2025-01-14T03:16:09.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>相信大家在使用pip安装依赖包时很头疼，下载的网速超级慢，那是因为使用pip install命令时默认使用国外的源：<a href="https://files.pythonhosted.org,不妨ping一下,是美国的ip/">https://files.pythonhosted.org，不妨ping一下，是美国的IP</a>.</strong> </p><h4 id="第1步：默认国外源："><a href="#第1步：默认国外源：" class="headerlink" title="第1步：默认国外源："></a>第1步：默认国外源：</h4><pre class="line-numbers language-none"><code class="language-none">如下命令：(venv) iMac:20180921-demo raoys$ pip3 install --upgrade pipCollecting pip  Downloading https://files.pythonhosted.org/packages/5f/25/  e52d3f31441505a5f3af41213346e5b6c221c9e086a166f3703d2ddaf940/pip-18.0-py2.py3-none-any.whl (1.3MB)    100% |████████████████████████████████| 1.3MB 556kB/s Installing collected packages: pip  Found existing installation: pip 10.0.1    Uninstalling pip-10.0.1:      Successfully uninstalled pip-10.0.1Successfully installed pip-18.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面教大家如何国内的源，体验飞的速度！！！</p><h4 id="第2步：介绍有哪些国内源："><a href="#第2步：介绍有哪些国内源：" class="headerlink" title="第2步：介绍有哪些国内源："></a>第2步：介绍有哪些国内源：</h4> <pre class="line-numbers language-none"><code class="language-none">清华：https://pypi.tuna.tsinghua.edu.cn/simple阿里云：http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/华中理工大学：http://pypi.hustunique.com/山东理工大学：http://pypi.sdutlinux.org/ 豆瓣：http://pypi.douban.com/simple/需要注意的是新版ubuntu要求使用https源。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第3步：开始使用国内源："><a href="#第3步：开始使用国内源：" class="headerlink" title="第3步：开始使用国内源："></a>第3步：开始使用国内源：</h4><p> <code>A、临时使用：可以在使用pip的时候加参数“-i https://pypi.tuna.tsinghua.edu.cn/simple”</code><br> <code>例如：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple requests，这样就会从清华这边的镜像去安装requests库。</code><br> </p><pre class="line-numbers language-none"><code class="language-none">(venv) iMac:20180921-demo raoys$ pip3 install -i https://pypi.tuna.tsinghua.edu.cn/simple requestsLooking in indexes: https://pypi.tuna.tsinghua.edu.cn/simpleCollecting requests  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/65/47  /7e02164a2a3db50ed6d8a6ab1d6d60b69c4c3fdf57a284257925dfc12bda/requests-2.19.1-py2.py3-none-any.whl (91kB)    100% |████████████████████████████████| 92kB 1.4MB/s Collecting urllib3&lt;1.24,&gt;=1.21.1 (from requests)  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/bd/c9  /6fdd990019071a4a32a5e7cb78a1d92c53851ef4f56f62a3486e6a7d8ffb/urllib3-1.23-py2.py3-none-any.whl (133kB)    100% |████████████████████████████████| 143kB 399kB/s Collecting chardet&lt;3.1.0,&gt;=3.0.2 (from requests)  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/bc/a9  /01ffebfb562e4274b6487b4bb1ddec7ca55ec7510b22e4c51f14098443b8/chardet-3.0.4-py2.py3-none-any.whl (133kB)    100% |████████████████████████████████| 143kB 2.1MB/s Collecting idna&lt;2.8,&gt;=2.5 (from requests)  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/4b/2a  /0276479a4b3caeb8a8c1af2f8e4355746a97fab05a372e4a2c6a6b876165/idna-2.7-py2.py3-none-any.whl (58kB)    100% |████████████████████████████████| 61kB 2.2MB/s Collecting certifi&gt;=2017.4.17 (from requests)  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/df/f7  /04fee6ac349e915b82171f8e23cee63644d83663b34c539f7a09aed18f9e/certifi-2018.8.24-py2.py3-none-any.whl (147kB)    100% |████████████████████████████████| 153kB 1.9MB/s Installing collected packages: urllib3, chardet, idna, certifi, requestsSuccessfully installed certifi-2018.8.24 chardet-3.0.4 idna-2.7 requests-2.19.1 urllib3-1.23(venv) iMac:20180921-demo raoys$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p></p><p><code>B、永久修改，一劳永逸：</code></p><pre class="line-numbers language-none"><code class="language-none">Linux: 修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)MacOS: 修改 ~/.pip/pip.conf (没有就创建一个文件夹及文件。文件夹要加“.”，表示是隐藏文件夹)windows:，直接在user目录中创建一个pip目录，再新建文件pip.ini。例如：C:\Users\jason\pip\pip.ini内容如下：[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=mirrors.aliyun.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>C、配置后直接使用pip instal命令即可，无需加任何参数，如下命令：</code></p><pre class="line-numbers language-none"><code class="language-none">(venv) iMac:20180921-demo raoys$ cd ~(venv) iMac:~ raoys$ mkdir .pip(venv) iMac:~ raoys$ cd .pip/(venv) iMac:.pip raoys$ vi pip.conf(venv) iMac:.pip raoys$ pip3 install beautifulsoup4Looking in indexes: https://pypi.tuna.tsinghua.edu.cn/simpleCollecting beautifulsoup4  Downloading https://pypi.tuna.tsinghua.edu.cn/packages/21/0a  /47fdf541c97fd9b6a610cb5fd518175308a7cc60569962e776ac52420387/beautifulsoup4-4.6.3-py3-none-any.whl (90kB)    100% |████████████████████████████████| 92kB 1.3MB/s Installing collected packages: beautifulsoup4Successfully installed beautifulsoup4-4.6.3(venv) iMac:.pip raoys$ <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上就是pip使用国内源的所有步骤。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;相信大家在使用pip安装依赖包时很头疼，下载的网速超级慢，那是因为使用pip install命令时默认使用国外的源：&lt;a href=&quot;https://files.pythonhosted.org,不妨ping一下,是美国的ip/&quot;&gt;https://files</summary>
      
    
    
    
    <category term="后端" scheme="https://raoys.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Python" scheme="https://raoys.github.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>git remote: HTTP Basic: Access denied 错误解决办法</title>
    <link href="https://raoys.github.io/2017/10/13/it-git-02.html"/>
    <id>https://raoys.github.io/2017/10/13/it-git-02.html</id>
    <published>2017-10-13T14:13:13.000Z</published>
    <updated>2025-01-14T03:16:09.135Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题描述</strong> </p><ul><li>git push or git clone 报 HTTP Basic: Access denied 错误</li></ul><h4 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h4><pre><code>本地git配置的用户名、密码与gitlabs上注册的用户名、密码不一致。 </code></pre><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><pre class="line-numbers language-none"><code class="language-none">1. 如果账号密码有变动 用这个命令：    git config –-system –-unset credential.helper         然后重新输入账号密码 应该就能解决了；    2. 如果用了第一个命令 还不能解决问题那么 用这个命令：    git config –-global http.emptyAuth true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;问题描述&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git push or git clone 报 HTTP Basic: Access denied 错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;原因&quot;&gt;&lt;a href=&quot;#原因&quot; class=&quot;head</summary>
      
    
    
    
    <category term="后端" scheme="https://raoys.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Git" scheme="https://raoys.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Redis工具类对各种数据类型的操作</title>
    <link href="https://raoys.github.io/2017/10/13/it-redis-01.html"/>
    <id>https://raoys.github.io/2017/10/13/it-redis-01.html</id>
    <published>2017-10-13T13:04:22.000Z</published>
    <updated>2025-01-14T03:16:09.139Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Redis工具类对string，list，hash，set，zset数据类型的操作。</strong> </p><h4 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h4><pre class="line-numbers language-none"><code class="language-none">&lt;dependency&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Redis代码配置"><a href="#Redis代码配置" class="headerlink" title="Redis代码配置"></a>Redis代码配置</h4><pre class="line-numbers language-none"><code class="language-none">import org.springframework.beans.factory.annotation.Autowired;import org.springframework.cache.annotation.EnableCaching;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.Configuration;import org.springframework.data.redis.connection.RedisConnectionFactory;import org.springframework.data.redis.core.*;  /** *  * Redis模板配置，缓存配置 */  @Configuration@EnableCachingpublic class RedisConfig {      @Autowired    RedisConnectionFactory redisConnectionFactory;      /**     * 实例化 RedisTemplate 对象     */    @Bean    public RedisTemplate&lt;String, Object&gt; functionDomainRedisTemplate() {        RedisTemplate&lt;String, Object&gt; redisTemplate = new RedisTemplate&lt;String, Object&gt;();        initDomainRedisTemplate(redisTemplate, redisConnectionFactory);        return redisTemplate;    }      /**     * 设置数据存入 redis 的序列化方式     */    private void initDomainRedisTemplate(RedisTemplate&lt;String, Object&gt; redisTemplate, RedisConnectionFactory factory) {        /***        redisTemplate.setKeySerializer(new StringRedisSerializer());        redisTemplate.setValueSerializer(new JdkSerializationRedisSerializer());        redisTemplate.setHashKeySerializer(new StringRedisSerializer());        redisTemplate.setHashValueSerializer(new Jackson2JsonRedisSerializer(Object.class));        */        redisTemplate.setConnectionFactory(factory);    }      /**     * 实例化 HashOperations 对象,可以使用 Hash 类型操作     */    @Bean    public HashOperations&lt;String, String, Object&gt; hashOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {        return redisTemplate.opsForHash();    }      /**     * 实例化 ValueOperations 对象,可以使用 String 操作     */    @Bean    public ValueOperations&lt;String, Object&gt; valueOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {        return redisTemplate.opsForValue();    }      /**     * 实例化 ListOperations 对象,可以使用 List 操作     */    @Bean    public ListOperations&lt;String, Object&gt; listOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {        return redisTemplate.opsForList();    }      /**     * 实例化 SetOperations 对象,可以使用 Set 操作     */    @Bean    public SetOperations&lt;String, Object&gt; setOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {        return redisTemplate.opsForSet();    }      /**     * 实例化 ZSetOperations 对象,可以使用 ZSet 操作     */    @Bean    public ZSetOperations&lt;String, Object&gt; zSetOperations(RedisTemplate&lt;String, Object&gt; redisTemplate) {        return redisTemplate.opsForZSet();    }     }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="Redis操作代码"><a href="#Redis操作代码" class="headerlink" title="Redis操作代码"></a>Redis操作代码</h4><pre class="line-numbers language-none"><code class="language-none">import org.springframework.beans.factory.annotation.Autowired;import org.springframework.data.redis.core.*;import org.springframework.stereotype.Service;  import javax.annotation.Resource;import java.util.List;import java.util.Map;import java.util.Set;import java.util.concurrent.TimeUnit;  @Servicepublic class RedisService {        @Autowired    private RedisTemplate&lt;String, Object&gt; redisTemplate;     // HashMap操作    @Resource    private HashOperations&lt;String, String, Object&gt; hashOperations;    // Object操作    @Resource    private ValueOperations&lt;String, Object&gt; valueOperations;     // List操作    @Resource    private ListOperations&lt;String, Object&gt; listOperations;       // set操作    @Resource    private SetOperations&lt;String, Object&gt; setOperations;     // ZSet操作    @Resource    private ZSetOperations&lt;String, Object&gt; zSetOperations;      //---------------------------------------------------------------------    // redisTemplate    //---------------------------------------------------------------------      /**     * 判断key是否存在     * @param key     */    public boolean hasKey(String key) {        return redisTemplate.hasKey(key);    }      /**     * 删除key     * @param key     */    public void delete(String key){        redisTemplate.delete(key);    }      /**     * 判断指定key的hashKey是否存在     * @param key     * @param hashKey     * @return     */    public boolean hasKey(String key, String hashKey) {        return redisTemplate.opsForHash().hasKey(key, hashKey);    }      /**     * 设置超时时间     * @param key     * @param timeout     * @param unit     */    public void expire(String key, final long timeout, final TimeUnit unit) {        redisTemplate.expire(key, timeout, unit);    }      /**     * 获取过期时间     * @param key     * @return     */    public long ttl(String key){        return redisTemplate.getExpire(key);    }      /**     * 获取指定pattern的key     * @param pattern     * @return     */    public Set&lt;String&gt; keys(String pattern) {        return redisTemplate.keys(pattern);    }      /**     * 删除多个key     * @param keys     */    public void delete(Set&lt;String&gt; keys) {        redisTemplate.delete(keys);    }      /**     * 设置过期时间     * @param key     * @param expire     */    private void setExpire (String key,long expire){        if (expire != -1) {            redisTemplate.expire(key, expire, TimeUnit.SECONDS);        }    }      //---------------------------------------------------------------------    // ValueOperations -&gt; Redis String/Value 操作    //---------------------------------------------------------------------      /**     * 设置key-value值     */    public void addValue(String key, Object value,long expire){        valueOperations.set(key, value);          setExpire(key,expire);    }      /**     * 设置key-value值,传入时间单位     */    public void addValue(String key, Object value,long expire, TimeUnit timeUnit){        valueOperations.set(key, value, expire, timeUnit);      }      /**     * 设置key-value值, 无过期时间     */    public void addValue(String key, Object value){        valueOperations.set(key, value);    }      /**     * 获取key的值     *     */    public Object getValue(String key){        return valueOperations.get(key);    }      //---------------------------------------------------------------------    // HashOperations -&gt; Redis Redis Hash 操作    //---------------------------------------------------------------------      /**     * 向redis 中添加内容     * @param key       保存key     * @param hashKey   hashKey     * @param data      保存对象 data     * @param expire    过期时间    -1：表示不过期     */    public void addHashValue(String key,String hashKey, Object data, long expire) {        hashOperations.put(key, hashKey, data);          setExpire(key,expire);    }      /**     * Hash 添加数据     * @param key   key     * @param map   data     */    public void addAllHashValue(String key, Map&lt;String, Object&gt; map, long expire) {        hashOperations.putAll(key, map);          setExpire(key,expire);    }      /**     * 删除hash key     * @param key       key     * @param hashKey   hashKey     */    public long deleteHashValue(String key, String hashKey) {        return hashOperations.delete(key, hashKey);    }      /**     * 获取数据     */    public Object getHashValue(String key, String hashKey) {        return hashOperations.get(key, hashKey);    }      /**     * 批量获取数据     */    public List&lt;Object&gt; getHashAllValue(String key) {        return hashOperations.values(key);    }      /**     * 批量获取指定hashKey的数据     */    public List&lt;Object&gt; getHashMultiValue(String key, List&lt;String&gt; hashKeys) {        return  hashOperations.multiGet(key, hashKeys);    }      /**     * 获取hash数量     */    public Long getHashCount(String key) {        return hashOperations.size(key);    }        //---------------------------------------------------------------------    // ZSetOperations -&gt; Redis Sort Set 操作    //---------------------------------------------------------------------      /**     * 设置zset值     */    public boolean addZSetValue(String key, Object member, long score){        return zSetOperations.add(key, member, score);    }      /**     * 设置zset值     */    public boolean addZSetValue(String key, Object member, double score){        return zSetOperations.add(key, member, score);    }      /**     * 批量设置zset值     */    public long addBatchZSetValue(String key, Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; tuples){        return zSetOperations.add(key, tuples);    }      /**     * 自增zset值     */    public void incZSetValue(String key, String member, long delta){        zSetOperations.incrementScore(key, member, delta);    }      /**     * 获取zset数量     */    public long getZSetScore(String key, String member){        Double score = zSetOperations.score(key, member);        if(score==null){            return 0;        }else{            return score.longValue();        }    }      /**     * 获取有序集 key 中成员 member 的排名 。其中有序集成员按 score 值递减 (从小到大) 排序。     */    public Set&lt;ZSetOperations.TypedTuple&lt;Object&gt;&gt; getZSetRank(String key, long start, long end){        return zSetOperations.rangeWithScores(key, start, end);    }        //---------------------------------------------------------------------    // listOperations -&gt; Redis List() 操作    //---------------------------------------------------------------------      /**     * 添加list列表     */    public void addListValue(String key,Object list){        listOperations.leftPush(key,list);    }      /**     * 获取指定Key对应的list     */    public Object getListValue(String key){        return listOperations.leftPop(key);    }      //---------------------------------------------------------------------    // setOperations -&gt; Redis Set() 操作    //---------------------------------------------------------------------      /**     * 添加Set集合集合     */    public void addSetValue(String key,Object list){        setOperations.add(key,list);    }      /**     * 获取指定Key对应的set     */    public Object getSetValue(String key){        return setOperations.members(key);    }      /**     * 获取并移除指定key的值     */    public Object popSetValue(String key){        return setOperations.pop(key);    }  }<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Redis工具类对string，list，hash，set，zset数据类型的操作。&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;添加依赖&quot;&gt;&lt;a href=&quot;#添加依赖&quot; class=&quot;headerlink&quot; title=&quot;添加依赖&quot;&gt;&lt;/a&gt;添加依赖&lt;/</summary>
      
    
    
    
    <category term="后端" scheme="https://raoys.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Redis" scheme="https://raoys.github.io/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>Git常用命令列表</title>
    <link href="https://raoys.github.io/2017/10/12/it-git-01.html"/>
    <id>https://raoys.github.io/2017/10/12/it-git-01.html</id>
    <published>2017-10-12T14:13:13.000Z</published>
    <updated>2025-01-14T03:16:09.135Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Git常用命令整理：</strong> </p><ul><li>根据多个项目实践整理下面的git命令大全，留着后续使用。</li></ul><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><pre><code># 在当前目录新建一个Git代码库$ git init # 新建一个目录，将其初始化为Git代码库$ git init [project-name] # 下载一个项目和它的整个代码历史$ git clone [url] </code></pre><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><pre><code># 显示当前的Git配置$ git config --list # 编辑Git配置文件$ git config -e [--global] # 设置提交代码时的用户信息$ git config [--global] user.name "[name]"$ git config [--global] user.email "[email address]" </code></pre><h4 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h4><pre><code># 添加指定文件到暂存区$ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录$ git add [dir] # 添加当前目录的所有文件到暂存区$ git add . # 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p # 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ... # 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] </code></pre><h4 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h4><pre><code># 提交暂存区到仓库区$ git commit -m [message] # 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a # 提交时显示所有diff信息$ git commit -v # 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... </code></pre><h4 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h4><pre><code># 列出所有本地分支$ git branch # 列出所有远程分支$ git branch -r # 列出所有本地分支和远程分支$ git branch -a # 新建一个分支，但依然停留在当前分支$ git branch [branch-name] # 新建一个分支，并切换到该分支$ git checkout -b [branch]$ git checkout -b [local branch] [remote branch]eg:$ git checkout -b v1.0 origin/v1.0 # 新建一个分支，指向指定commit$ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区$ git checkout [branch-name] # 切换到上一个分支$ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支$ git merge [branch] # 选择一个commit，合并进当前分支$ git cherry-pick [commit] # 删除分支$ git branch -d [branch-name] # 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] </code></pre><h4 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h4><pre><code># 列出所有tag$ git tag # 新建一个tag在当前commit$ git tag [tag] # 新建一个tag在指定commit$ git tag [tag] [commit] # 删除本地tag$ git tag -d [tag] # 删除远程tag$ git push origin :refs/tags/[tagName] # 查看tag信息$ git show [tag] # 提交指定tag$ git push [remote] [tag] # 提交所有tag$ git push [remote] --tags # 新建一个分支，指向某个tag$ git checkout -b [branch] [tag]</code></pre><h4 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h4><pre><code># 显示有变更的文件$ git status # 显示当前分支的版本历史$ git log # 显示commit历史，以及每次commit发生变更的文件$ git log --stat # 搜索提交历史，根据关键词$ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件$ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file] # 显示指定文件相关的每一次diff$ git log -p [file] # 显示过去5次提交$ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序$ git shortlog -sn # 显示指定文件是什么人在什么时间修改过$ git blame [file] # 显示暂存区和工作区的差异$ git diff # 显示暂存区和上一个commit的差异$ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异$ git diff HEAD # 显示两次提交之间的差异$ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码$ git diff --shortstat "@{0 day ago}" # 显示某次提交的元数据和内容变化$ git show [commit] # 显示某次提交发生变化的文件$ git show --name-only [commit] # 显示某次提交时，某个文件的内容$ git show [commit]:[filename] # 显示当前分支的最近几次提交$ git reflog</code></pre><h4 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h4><pre><code># 下载远程仓库的所有变动$ git fetch [remote] # 显示所有远程仓库$ git remote -v # 显示某个远程仓库的信息$ git remote show [remote] # 增加一个新的远程仓库，并命名$ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] # 上传本地指定分支到远程仓库$ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force # 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h4 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h4><pre><code># 恢复暂存区的指定文件到工作区$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit] # 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Git常用命令整理：&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据多个项目实践整理下面的git命令大全，留着后续使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;仓库&quot;&gt;&lt;a href=&quot;#仓库&quot; class=&quot;headerlink&quot; title=&quot;仓库&quot;</summary>
      
    
    
    
    <category term="后端" scheme="https://raoys.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Git" scheme="https://raoys.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Nginx负载均衡之权重配置</title>
    <link href="https://raoys.github.io/2017/08/02/it-server-nginx-02.html"/>
    <id>https://raoys.github.io/2017/08/02/it-server-nginx-02.html</id>
    <published>2017-08-02T10:17:35.000Z</published>
    <updated>2025-01-14T03:16:09.142Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Nginx负载均衡之权重配置</strong> </p><h4 id="配置如下："><a href="#配置如下：" class="headerlink" title="配置如下："></a>配置如下：</h4><pre class="line-numbers language-none"><code class="language-none">user  www www;   ##nginx以www用户身份运行，需要建立www用户worker_processes  1;  ##工作进程，一般设置为auto自动#error_log  logs/error.log;#error_log  logs/error.log  notice;#error_log  logs/error.log  info;#pid        logs/nginx.pid;events {        use epoll;     worker_connections  65535;    ##线程，并且在系统中给到比他大的线程}http {    upstream aabbccdd{      ##算法    server 192.168.1.201:80 weight=2;   ##监控server的80端口，weigh为权重，2每访问两次，3访问一词    server 192.168.1.201:80 weight=2;}include       mime.types;server {                  ##设置虚拟主机        listen 80;        server_name www.aabbccdd.com;        location / {    调度算法                proxy_pass http://aabbccdd; ## 与上面upstream 配置的名称一致.        }} <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Nginx负载均衡之权重配置&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;配置如下：&quot;&gt;&lt;a href=&quot;#配置如下：&quot; class=&quot;headerlink&quot; title=&quot;配置如下：&quot;&gt;&lt;/a&gt;配置如下：&lt;/h4&gt;&lt;pre class=&quot;line-numb</summary>
      
    
    
    
    <category term="服务器" scheme="https://raoys.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="Nginx" scheme="https://raoys.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>Nginx监听一个端口多域名转发配置</title>
    <link href="https://raoys.github.io/2017/08/01/it-server-nginx-01.html"/>
    <id>https://raoys.github.io/2017/08/01/it-server-nginx-01.html</id>
    <published>2017-08-01T10:55:35.000Z</published>
    <updated>2025-01-14T03:16:09.140Z</updated>
    
    <content type="html"><![CDATA[<p><strong>Nginx监听一个端口多域名转发配置方法</strong> </p><h4 id="配置如下："><a href="#配置如下：" class="headerlink" title="配置如下："></a>配置如下：</h4><pre><code>worker_processes  1;events {    worker_connections  1024;}http {    include       mime.types;    default_type  application/octet-stream;    sendfile        on;    keepalive_timeout  65;    server {        listen       80;        server_name 192.168.1.x;        error_page 404 401 400  /400.html;        location / {                         root   html;            index 400.html;                }        location = /40x.html{            root html;        }    }        server {        listen       80;        server_name  test1.com.cn www.test1.com.cn;        location / {            proxy_pass  http://localhost:8080;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            root   html;            index  index.html index.htm;        }    }    server {        listen       80;        server_name  test2.com www.test2.com;        location / {            proxy_pass  http://localhost:8081;            proxy_set_header Host $host;            proxy_set_header X-Real-IP $remote_addr;            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;            root   html;            index  index.html index.htm;        }    }}</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;Nginx监听一个端口多域名转发配置方法&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;配置如下：&quot;&gt;&lt;a href=&quot;#配置如下：&quot; class=&quot;headerlink&quot; title=&quot;配置如下：&quot;&gt;&lt;/a&gt;配置如下：&lt;/h4&gt;&lt;pre&gt;&lt;code&gt;work</summary>
      
    
    
    
    <category term="服务器" scheme="https://raoys.github.io/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    
    
    <category term="Nginx" scheme="https://raoys.github.io/tags/Nginx/"/>
    
  </entry>
  
  <entry>
    <title>VMware中CentOS7静态IP的设置</title>
    <link href="https://raoys.github.io/2015/10/13/it-linux-centos-02.html"/>
    <id>https://raoys.github.io/2015/10/13/it-linux-centos-02.html</id>
    <published>2015-10-12T22:33:23.000Z</published>
    <updated>2025-01-14T03:16:09.138Z</updated>
    
    <content type="html"><![CDATA[<p><strong>VMware中CentOS7系统设置静态IP的步骤</strong> </p><h4 id="VMware下有三种网络连接模式"><a href="#VMware下有三种网络连接模式" class="headerlink" title="VMware下有三种网络连接模式"></a>VMware下有三种网络连接模式</h4><p>一、birdged（桥接）<br>桥接网络是指本地物理网卡和虚拟网卡通过VMnet0虚拟交换机进行桥接，物理网卡和虚拟网卡在拓扑图上处于同等地位，那么物理网卡和虚拟网卡就相当于处于同一个网段，虚拟交换机就相当于一台现实网络中的交换机,所以两个网卡的IP地址也要设置为同一网段。</p><p>二、NAT(网络地址转换)<br>NAT模式中，就是让虚拟机借助NAT(网络地址转换)功能，通过宿主机器所在的网络来访问公网。 NAT模式中，虚拟机的网卡和物理网卡的网络，不在同一个网络，虚拟机的网卡，是在VMware提供的一个虚拟网络。</p><p>三、Host-only(仅主机)<br>在Host-Only模式下，虚拟网络是一个全封闭的网络，它唯一能够访问的就是主机。其实Host-Only网络和NAT网络很相似，不同的地方就是Host-Only网络没有NAT服务，所以虚拟网络不能连接到Internet。主机和虚拟机之间的通信是通过VMware Network Adepter VMnet1虚拟网卡来实现的。</p><p>这里主要讨论桥接和NAT模式</p><h4 id="NAT和桥接的比较"><a href="#NAT和桥接的比较" class="headerlink" title="NAT和桥接的比较"></a>NAT和桥接的比较</h4><p>(1) NAT模式和桥接模式虚拟机都可以上外网。<br>(2) 由于NAT的网络在VMware提供的一个虚拟网络里，所以局域网其他主机是无法访问虚拟机的，而宿主机可以访问虚拟机，虚拟机可以访问局域网的所有主机，因为真实的局域网相对于NAT的虚拟网络，就是NAT的虚拟网络的外网，不懂的人可以查查NAT的相关知识。<br>(3) 桥接模式下，多个虚拟机之间可以互相访问；NAT模式下，多个虚拟机之间也可以相互访问。</p><h4 id="步骤1-在虚拟机中使用NAT"><a href="#步骤1-在虚拟机中使用NAT" class="headerlink" title="步骤1 在虚拟机中使用NAT"></a>步骤1 在虚拟机中使用NAT</h4><p><code>如图：</code><br><img src="/img/linux/2015-10-13-0633-linux-centos-01.png"></p><p>接下来看看在NAT模式下，进入到CentOS7系统后，该如何为其配置网络：</p><h4 id="步骤2-查看宿主机（本机）的默认网关"><a href="#步骤2-查看宿主机（本机）的默认网关" class="headerlink" title="步骤2 查看宿主机（本机）的默认网关"></a>步骤2 查看宿主机（本机）的默认网关</h4><p><code>如图：</code><br><img src="/img/linux/2015-10-13-0633-linux-centos-02.png"><br>上图为公司内外，默认网关为：10.0.0.1</p><h4 id="步骤3-配置VMware的NAT模式设置"><a href="#步骤3-配置VMware的NAT模式设置" class="headerlink" title="步骤3 配置VMware的NAT模式设置"></a>步骤3 配置VMware的NAT模式设置</h4><p><code>如图：</code><br><img src="/img/linux/2015-10-13-0633-linux-centos-03.png"></p><h4 id="步骤4-进入centos7系统，执行如下命令修改网络配置"><a href="#步骤4-进入centos7系统，执行如下命令修改网络配置" class="headerlink" title="步骤4 进入centos7系统，执行如下命令修改网络配置"></a>步骤4 进入centos7系统，执行如下命令修改网络配置</h4><pre class="line-numbers language-none"><code class="language-none">vi /etc/sysconfig/network-scripts/ifcfg-ens33<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">TYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static          # 静态IPDEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=ab60eed1-2349-495d-a33d-2a96c4f8cbb3DEVICE=ens33ONBOOT=yes                #随系统启动IPADDR=10.0.100.100       #设置固定IPNETMASK=255.255.255.0     GATEWAY=10.0.100.2        #第二步中 NAT设置中的网关IPDNS1=119.29.29.29         #DNSIP，基本上通用<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>保存后重启网络服务，执行如下命令：</p><pre class="line-numbers language-none"><code class="language-none">systemctl restart network.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="步骤5-最后验证网络配置是否成功"><a href="#步骤5-最后验证网络配置是否成功" class="headerlink" title="步骤5 最后验证网络配置是否成功"></a>步骤5 最后验证网络配置是否成功</h4><pre class="line-numbers language-none"><code class="language-none">ping baidu.com<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><code>结果如图：</code><br><img src="/img/linux/2015-10-13-0633-linux-centos-04.png"><br>如上图ping通了，就说明NAT模式下的网络配置成功了！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;VMware中CentOS7系统设置静态IP的步骤&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;VMware下有三种网络连接模式&quot;&gt;&lt;a href=&quot;#VMware下有三种网络连接模式&quot; class=&quot;headerlink&quot; title=&quot;VMware下有三</summary>
      
    
    
    
    <category term="Linux" scheme="https://raoys.github.io/categories/Linux/"/>
    
    
    <category term="CentOS" scheme="https://raoys.github.io/tags/CentOS/"/>
    
    <category term="VMware" scheme="https://raoys.github.io/tags/VMware/"/>
    
  </entry>
  
  <entry>
    <title>CentOS开机网络启动设置问题</title>
    <link href="https://raoys.github.io/2015/10/12/it-linux-centos-01.html"/>
    <id>https://raoys.github.io/2015/10/12/it-linux-centos-01.html</id>
    <published>2015-10-12T12:11:23.000Z</published>
    <updated>2025-01-14T03:16:09.138Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最新安装的CentOS系统，开机总是需要重新设置网络eth0，才能上网，现在下面做了一下设置，就可以开机后自己联网。</strong> </p><h4 id="步骤如下："><a href="#步骤如下：" class="headerlink" title="步骤如下："></a>步骤如下：</h4><pre class="line-numbers language-none"><code class="language-none">1，输入命令ifconfig，检查eth0设备网络是否没有启动；2，如果手动启动，输入命令ifup eth0即可；3，如果需要开机后自启动网络，则需要在文件 /etc/rc.local 里加入     /sbin/ifup eth0 ，这样重新启动，问题就解决了。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;最新安装的CentOS系统，开机总是需要重新设置网络eth0，才能上网，现在下面做了一下设置，就可以开机后自己联网。&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;步骤如下：&quot;&gt;&lt;a href=&quot;#步骤如下：&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Linux" scheme="https://raoys.github.io/categories/Linux/"/>
    
    
    <category term="CentOS" scheme="https://raoys.github.io/tags/CentOS/"/>
    
  </entry>
  
  <entry>
    <title>Java并行计算方案</title>
    <link href="https://raoys.github.io/2015/10/12/it-java-calc-forkjoin.html"/>
    <id>https://raoys.github.io/2015/10/12/it-java-calc-forkjoin.html</id>
    <published>2015-10-12T07:12:27.000Z</published>
    <updated>2025-01-14T03:16:09.137Z</updated>
    
    <content type="html"><![CDATA[<p><strong>a、ForkJoin描述：</strong> </p><ul><li>ForkJoin是Java7提供的原生多线程并行处理框架，其基本思想是将大任务分割成小任务，最后将小任务聚合起来得到结果。</li><li>fork是分解的意思, join是收集的意思. 它非常类似于HADOOP提供的MapReduce框架，只是MapReduce的任务可以针对集群内的所有计算节点，可以充分利用集群的能力完成计算任务。ForkJoin更加类似于单机版的MapReduce。</li></ul><p><img src="/img/java/2015-10-12-1512-forkjoin-01.png"></p><p><strong>b、注意事项：</strong> </p><ul><li>在fork/join框架中，若某个子问题由于等待另一个子问题的完成而无法继续执行。那么处理该子问题的线程会主动寻找其他尚未运行完成的子问题来执行。这种方式减少了线程的等待时间，提高了性能。子问题中应该避免使用synchronized关键词或其他方式方式的同步。也不应该是一阻塞IO或过多的访问共享变量。在理想情况下，每个子问题的实现中都应该只进行CPU相关的计算，并且只适用每个问题的内部对象。<strong>唯一的同步应该只发生在子问题和创建它的父问题之间。</strong></li></ul><p><strong>c、Fork/Join使用两个类完成以上两件事情：</strong></p><ul><li><p>ForkJoinTask: 我们要使用ForkJoin框架，必须首先创建一个ForkJoin任务。它提供在任务中执行fork()和join的操作机制，ForkJoinTask实现了Future接口，可以按照Future接口的方式来使用。在ForkJoinTask类中之重要的两个方法fork和join。fork方法用以一部方式启动任务的执行，join方法则等待任务完成并返回指向结果。在创建自己的任务是，最好不要直接继承自ForkJoinTask类，而要继承自ForkJoinTask类的子类RecurisiveTask或RecurisiveAction类。<br><code>1. RecursiveAction，用于没有返回结果的任务</code><br><code>2. RecursiveTask，用于有返回值的任务</code><br><img src="/img/java/2015-10-12-1512-forkjoin-02.png"></p></li><li><p>ForkJoinPool：task要通过ForkJoinPool来执行，分割的子任务也会添加到当前工作线程的双端队列中，进入队列的头部。当一个工作线程中没有任务时，会从其他工作线程的队列尾部获取一个任务。</p></li><li><p>2个构造方法</p></li></ul><pre class="line-numbers language-none"><code class="language-none">ForkJoinPool(int parallelism)  创建一个包含parallelism个并行线程的ForkJoinPool。ForkJoinPool()  以Runtime.availableProcessors()方法的返回值作为parallelism参数来创建ForkJoinPool。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>3种方式启动</li></ul><pre class="line-numbers language-none"><code class="language-none">异步执行        　 execute(ForkJoinTask)    　　　　 ForkJoinTask.fork等待获取结果    　　invoke(ForkJoinTask)    　　　　  ForkJoinTask.invoke执行,获取Future    submit(ForkJoinTask)  　　　　　　ForkJoinTask.fork(ForkJoinTask are Futures)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>d、异常处理: ：</strong></p><ul><li><p>ForkJoinTask在执行的时候可能会抛出异常，但是没办法在主线程里直接捕获异常，所以ForkJoinTask提供了isCompletedAbnormally()方法来检查任务是否已经抛出异常或已经被取消了，并且可以通过ForkJoinTask的getException方法获取异常.</p></li><li><p>getException方法返回Throwable对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回null。</p></li></ul><pre class="line-numbers language-none"><code class="language-none">if(task.isCompletedAbnormally()) {    System.out.println(task.getException());}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p> <strong>e、代码展示</strong></p><pre class="line-numbers language-none"><code class="language-none">import java.util.concurrent.ForkJoinPoolimport java.util.concurrent.ForkJoinTaskimport java.util.concurrent.RecursiveTask/** * fork * 对一个大数组进行并行求和的RecursiveTask * * 大任务可以拆成小任务，小任务还可以继续拆成更小的任务，最后把任务的结果汇总合并，得到最终结果，这种模型就是Fork/Join模型。 Java7引入了Fork/Join框架，我们通过RecursiveTask这个类就可以方便地实现Fork/Join模式。 * Created by wenbronk on 2017/7/13. */class ForkJoinTest extends RecursiveTask&lt;Long&gt; {    static final int THRESHOLD = 100    long[] array    int start    int end    ForkJoinTest(long[] array, int start, int end) {        this.start = start        this.end = end        this.array = array    }    @Override    protected Long compute() {        if (end - start &lt; THRESHOLD) {            long sum = 0            for (int i = start; i &lt; end; i++) {                sum += array[i]            }            try {                Thread.sleep(100)            } catch (Exception e) {                e.printStackTrace()            }            println String.format('compute %d %d = %d', start, end, sum)        }        // 对于大任务, 分多线程执行        int middle = (end + start) / 2        println String.format('split %d %d =&gt; %d %d, %d %d', start, end, start, middle, middle, end)        def subtask1 = new ForkJoinTest(this.array, start, middle);        def subtask2 = new ForkJoinTest(this.array, middle, end);        invokeAll(subtask1, subtask2)        Long subresult1 = subtask1.join()        Long subresult2 = subtask2.join()        Long result = subresult1 + subresult2        System.out.println("result = " + subresult1 + " + " + subresult2 + " ==&gt; " + result);        return result    }    public static void main(String[] args) throws Exception {        // 创建随机数组成的数组:        long[] array = new long[400];//        fillRandom(array);        // fork/join task:        ForkJoinPool fjp = new ForkJoinPool(4); // 最大并发数4        ForkJoinTask&lt;Long&gt; task = new ForkJoinTest(array, 0, array.length);        long startTime = System.currentTimeMillis();        Long result = fjp.invoke(task);        long endTime = System.currentTimeMillis();        System.out.println("Fork/join sum: " + result + " in " + (endTime - startTime) + " ms.");    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>f、java代码的实现</strong></p><pre class="line-numbers language-none"><code class="language-none">package com.doordu.pingan.demo;import java.util.concurrent.ExecutionException;import java.util.concurrent.ForkJoinPool;import java.util.concurrent.ForkJoinTask;import java.util.concurrent.RecursiveTask;/** * forkjoin的简单易用 * Created by wenbronk on 2017/7/26. */public class CountTask extends RecursiveTask&lt;Integer&gt;{    private volatile static int count = 0;    private int start;    private int end;    public CountTask(int start, int end) {        this.start = start;        this.end = end;    }    public static final int threadhold = 2;    @Override    protected Integer compute() {        int sum = 0;        System.out.println("开启了一条线程单独干: " + count++);        // 如果任务足够小, 就直接执行        boolean canCompute = (end - start) &lt;= threadhold;        if (canCompute) {            for (int i = start; i &lt;= end; i++) {                sum += i;            }        }else {            //任务大于阈值, 分裂为2个任务            int middle = (start + end) / 2;            CountTask countTask1 = new CountTask(start, middle);            CountTask countTask2 = new CountTask(middle + 1, end);            // 开启线程//            countTask1.fork();//            countTask2.fork();            invokeAll(countTask1, countTask2);            Integer join1 = countTask1.join();            Integer join2 = countTask2.join();            // 结果合并            sum = join1 + join2;        }        return sum;    }    // 测试    public static void main(String[] args) throws ExecutionException, InterruptedException {        ForkJoinPool forkJoinPool = new ForkJoinPool();        CountTask countTask = new CountTask(1, 100);        ForkJoinTask&lt;Integer&gt; result = forkJoinPool.submit(countTask);        System.out.println(result.get());    }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p> <strong>g、work-stealing</strong></p><ul><li>g-1 forkjoin 框架是有 work-steal 机制的，这个机制主要功能是：<br><code>“空闲的” worker thread 从其它 worker thread 的 workQueue 里取得“未执行”的 task 然后执行。</code></li><li>g-2 具体细节机制如下：</li></ul><pre class="line-numbers language-none"><code class="language-none">1、每个 worker thread 维护自己的 scheduling 队列中的“可运行的”task - 队列是一个双向队列（称作：deques），支持 LIFO 和 FIFO 操作。2、在task 中生成的“子task”，会被放进生成它的 task 所在的 worker thread 的 双向队列。3、worker thread 处理双向队列中的 task 时，使用的是 LIFO 规则（最后进来的，最先被处理）4、当worker thread 的队列时没有任务可执行时，它会随机地偷取别的 worker thread 的 work queue 里的 task，然后执行它。在偷取时，使用的是 FIFO 规则，即偷取别人队列里“最先进入”队列的 task。5、当 worker thread 执行时，遇到了一个join操作（例如：newTask.join），它会暂停当前的 task 的处理，而来处理这个join操作所要执行的任务内容。直到这个join操作的任务执行完后，才会返回刚才暂停任务，继续执行被暂停任务的其它内容。所有 task 都会在不进行“阻塞”情况下完成。 （这里的“阻塞”的意思，个人理解为不是IO操作的那种阻塞，而是在任务调试时，没有具体的“阻塞”处理（例如：ArrayBlockingQueue的那种阻塞），或是没有用“阻塞的方式”进行任务调度）之前以为每次调用 fork 方法，都会生成一个线程，看了源码和进行Debug后才知道：根据构造函数中的parallelism值来，决定是否启动新线程。 在 fork 方法中，((ForkJoinWorkerThread)t).workQueue.push(this)这语句会把任务加到“当前线程的workQueue”里，进行排队。然后调用signalWork方法，来看是否还可以启动新线程来处理“未分配任务”。如果可以，就启动新线程处理任务。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">当 worker thread 没有要执行的 task 或者偷取任务失败时，就会进行暂时等待处理（通过yield，sleep，或者调整优先度等方式），过一段时间再重试看看有没有任务可以执行。如果所有的 worker thread 都处于闲置状态， 等待上层的发送 task 过来的话，就不会进行重试（看是否有任务可以执行）。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>g-3 work-stealing的“LIFO和FIFO”处理方式有两点好处：</li></ul><pre class="line-numbers language-none"><code class="language-none">1、减少了取 task 时的竞争。worker thread 在执行自己队列任务时，是使用从尾部取。别人从它的队列里偷取任务时，是从队列头部取。所以减少了取时的竞争。2、被偷取的任务，一般都是最早入队列的任务。这种任务一般来说，都是非常大的任务，是那种需要进行递归分析的的大任务，而不是那种分解完的小任务。所以，减少了任务偷取的次数。 （注意：在实现上，worker thread 在执行自己队列任务时，不总是 LIFO 方式，可以通过构造函数修改成 FIFO 方式）<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>g-4 关于双向队列</li></ul><pre class="line-numbers language-none"><code class="language-none">双向队列在实现方面的主要挑战是“同步”和“its avoidance（不知道怎么翻译）”。即使JVM优化了同步功能，每次 push 和 pop 时都要获取锁的这种操作，也会变成瓶颈。但是，一些策略的改变，提供了一种解决方案：push 和 pop 操作，只针对本线程内的队列。“偷取”操作可以很方便地通过一个“偷取锁”，来进行限制（双向锁在情况需要时，也可以使“偷取”操作失效）。因此，在队列两端的同步问题上的控制操作，就会减少。当双向队列要变成空时，可以对pop 或“偷取”操作进行控制。不然，这两个操作要被担保，可以操作disjoint elements of the array<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;a、ForkJoin描述：&lt;/strong&gt; &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ForkJoin是Java7提供的原生多线程并行处理框架，其基本思想是将大任务分割成小任务，最后将小任务聚合起来得到结果。&lt;/li&gt;
&lt;li&gt;fork是分解的意思, join是收集的意</summary>
      
    
    
    
    <category term="后端" scheme="https://raoys.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="JAVA" scheme="https://raoys.github.io/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>问题记录-Mysql 1449 The user specified as a definer (&#39;root&#39;@&#39;%&#39;) does not exist 解决方法</title>
    <link href="https://raoys.github.io/2015/10/04/it-db-mysql-01.html"/>
    <id>https://raoys.github.io/2015/10/04/it-db-mysql-01.html</id>
    <published>2015-10-04T11:18:31.000Z</published>
    <updated>2025-01-14T03:16:09.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最近做项目是将线上数据库导入到本地localhost后程序调用视图时报mysql 1449错误。</strong> </p><h4 id="问题说明："><a href="#问题说明：" class="headerlink" title="问题说明："></a>问题说明：</h4><pre class="line-numbers language-none"><code class="language-none">从一个数据库数据迁移到本地localhost程序在调用到数据库的视图时报错，直接在数据库中打开视图时也报错，类似：mysql 1449 ： The user specified as a definer ('montor'@'%') does not exist经查，是权限问题，解决办法 授权 给 root  所有sql 的权限。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>如图所示</code></p><p><img src="/img/db/2015-10-04-1918-mysql-01.png"></p><h4 id="解决问题："><a href="#解决问题：" class="headerlink" title="解决问题："></a>解决问题：</h4><pre class="line-numbers language-none"><code class="language-none">1，授权 给 root  所有sql 权限;2，运行：grant all privileges on *.* to monitor@"%" identified by ".";mysql&gt; grant all privileges on *.* to root@"%" identified by ".";Query OK, 0 rows affected (0.00 sec)mysql&gt; flush privileges;Query OK, 0 rows affected (0.00 sec)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>最后打开视图时便不会报错，程序调用也不会报错。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;最近做项目是将线上数据库导入到本地localhost后程序调用视图时报mysql 1449错误。&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;问题说明：&quot;&gt;&lt;a href=&quot;#问题说明：&quot; class=&quot;headerlink&quot; title=&quot;问题说明：&quot;&gt;&lt;</summary>
      
    
    
    
    <category term="数据库" scheme="https://raoys.github.io/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
    <category term="MySQL" scheme="https://raoys.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>解决eclipse中git插件中的cannot open git-upload-pack问题</title>
    <link href="https://raoys.github.io/2015/10/03/it-java-tool-02.html"/>
    <id>https://raoys.github.io/2015/10/03/it-java-tool-02.html</id>
    <published>2015-10-02T23:15:22.000Z</published>
    <updated>2025-01-14T03:16:09.137Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最近使用Eclipse向git同步代码时，出现cannot open git-upload-pack这个问题，后来找资料发现是Eclipse中git插件的配置问题。</strong> </p><h4 id="下面是处理方法："><a href="#下面是处理方法：" class="headerlink" title="下面是处理方法："></a>下面是处理方法：</h4><p><code>1):打开eclipse中的windows--&gt;Preferences--&gt;Team--&gt;Git--&gt;Configuration--&gt;User Settings.</code><br><code>2):然后点Add Entry新建一个键值对，输入http.sslVerify=false</code></p><p>如图所示:</p><p><img src="/img/java/2015-10-03-0712-jdk-tools-04.png"></p><p>然后确定即可解决问题，之后就发现git可以正常的pull和push了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;最近使用Eclipse向git同步代码时，出现cannot open git-upload-pack这个问题，后来找资料发现是Eclipse中git插件的配置问题。&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;下面是处理方法：&quot;&gt;&lt;a href=&quot;#下面是处</summary>
      
    
    
    
    <category term="后端" scheme="https://raoys.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Git" scheme="https://raoys.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>jvisualvm监控远程SpringBoot应用</title>
    <link href="https://raoys.github.io/2015/10/03/it-java-tool-01.html"/>
    <id>https://raoys.github.io/2015/10/03/it-java-tool-01.html</id>
    <published>2015-10-02T23:12:36.000Z</published>
    <updated>2025-01-14T03:16:09.137Z</updated>
    
    <content type="html"><![CDATA[<p><strong>使用Java自带jvisualvm工具来监控远程SpringBoot应用的运行情况步骤</strong> </p><h4 id="第一步骤：增加启动参数配置："><a href="#第一步骤：增加启动参数配置：" class="headerlink" title="第一步骤：增加启动参数配置："></a>第一步骤：增加启动参数配置：</h4><p>通常SpringBoot应用启动方式为：</p><p>java -jar springboot应用.jar</p><p>远程监控命令在java 与-jar之间增加，如下：<br><code>java -Djava.rmi.server.hostname=10.0.0.222 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=60001 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false -jar springboot应用.jar 即可</code></p><p>格式化后如下：</p><pre class="line-numbers language-none"><code class="language-none">java  \-Djava.rmi.server.hostname=10.0.0.222 \-Dcom.sun.management.jmxremote \-Dcom.sun.management.jmxremote.port=60001 \-Dcom.sun.management.jmxremote.authenticate=false \-Dcom.sun.management.jmxremote.ssl=false \-jar springboot应用.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>是不是觉得启动参数太长了，可以在系统环境变量中配置这些参数，如在/etc/profile 最后一行增加：</p><pre class="line-numbers language-none"><code class="language-none">export JAVA_OPTS='-Djava.rmi.server.hostname=10.0.0.222 -Dcom.sun.management.jmxremote -Dcom.sun.management.jmxremote.port=60001 -Dcom.sun.management.jmxremote.authenticate=false -Dcom.sun.management.jmxremote.ssl=false'执行 source /etc/profile ，是环境变量立马生效；<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>配置完环境变量后，只需执行如下命令即可完成远程监控：<br><code>java $JAVA_OPTS -jar springboot应用.jar</code></p><h4 id="第二步骤：配置jvisualvm"><a href="#第二步骤：配置jvisualvm" class="headerlink" title="第二步骤：配置jvisualvm"></a>第二步骤：配置jvisualvm</h4><p><code>a，添加远程主机：</code><br><img src="/img/java/2015-10-03-0712-jdk-tools-01.png"></p><p><code>b，右键已添加的远程主机，添加JMX连接，如图：</code></p><p><img src="/img/java/2015-10-03-0712-jdk-tools-02.png"></p><p><code>c，点击确定即可完成配置</code></p><p><code>d，最后双击已经填好的JMX连接，就能监控到cpu、堆、类、线程的使用情况，如下图：</code></p><p><img src="/img/java/2015-10-03-0712-jdk-tools-03.png"></p><p>看到上图表示配置成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;使用Java自带jvisualvm工具来监控远程SpringBoot应用的运行情况步骤&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;第一步骤：增加启动参数配置：&quot;&gt;&lt;a href=&quot;#第一步骤：增加启动参数配置：&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="后端" scheme="https://raoys.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="SpringBoot" scheme="https://raoys.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Zookeeper 集群搭建</title>
    <link href="https://raoys.github.io/2015/10/02/it-backend-zk-01.html"/>
    <id>https://raoys.github.io/2015/10/02/it-backend-zk-01.html</id>
    <published>2015-10-02T09:59:11.000Z</published>
    <updated>2025-01-14T03:16:09.134Z</updated>
    
    <content type="html"><![CDATA[<p><strong>如近分布式架构常用到Zookeeper组建，下面来介绍下Zookeeper集群的搭建方法</strong> </p><h4 id="第一步：下载并上传zookeeper-3-4-6-tar-gz到各个服务器的-usr-local-目录-或者使用wget命令"><a href="#第一步：下载并上传zookeeper-3-4-6-tar-gz到各个服务器的-usr-local-目录-或者使用wget命令" class="headerlink" title="第一步：下载并上传zookeeper-3.4.6.tar.gz到各个服务器的/usr/local/目录,或者使用wget命令"></a>第一步：下载并上传zookeeper-3.4.6.tar.gz到各个服务器的/usr/local/目录,或者使用wget命令</h4><pre class="line-numbers language-none"><code class="language-none">cd /usr/local/wget http://apache.fayea.com/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gztar -zxvf zookeeper-3.4.6.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="第二步：在各个服务器上解压zookeeper安装包，并按节点号对zookeeper目录重命名"><a href="#第二步：在各个服务器上解压zookeeper安装包，并按节点号对zookeeper目录重命名" class="headerlink" title="第二步：在各个服务器上解压zookeeper安装包，并按节点号对zookeeper目录重命名"></a>第二步：在各个服务器上解压zookeeper安装包，并按节点号对zookeeper目录重命名</h4><pre class="line-numbers language-none"><code class="language-none"># 服务器1cp -r zookeeper-3.4.6 zookeeper-3.4.6_1# 服务器2cp -r zookeeper-3.4.6 zookeeper-3.4.6_2# 服务器3cp -r zookeeper-3.4.6 zookeeper-3.4.6_3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第三步：在各zookeeper节点目录下创建以下目录"><a href="#第三步：在各zookeeper节点目录下创建以下目录" class="headerlink" title="第三步：在各zookeeper节点目录下创建以下目录"></a>第三步：在各zookeeper节点目录下创建以下目录</h4><pre class="line-numbers language-none"><code class="language-none">cd /usr/local/zookeeper-3.4.6_1mkdir datamkdir logscd /usr/local/zookeeper-3.4.6_2mkdir datamkdir logscd /usr/local/zookeeper-3.4.6_3mkdir datamkdir logs<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第四步：将各节点zookeeper-zookeeper-3-4-6-x-conf目录下的zoo-sample-cfg文件拷贝一份，命名为zoo-cfg"><a href="#第四步：将各节点zookeeper-zookeeper-3-4-6-x-conf目录下的zoo-sample-cfg文件拷贝一份，命名为zoo-cfg" class="headerlink" title="第四步：将各节点zookeeper/zookeeper-3.4.6_x/conf目录下的zoo_sample.cfg文件拷贝一份，命名为zoo.cfg"></a>第四步：将各节点zookeeper/zookeeper-3.4.6_x/conf目录下的zoo_sample.cfg文件拷贝一份，命名为zoo.cfg</h4><pre class="line-numbers language-none"><code class="language-none">cd /usr/local/zookeeper-3.4.6_1/confcp zoo_sample.cfg zoo.cfgcd /usr/local/zookeeper-3.4.6_2/confcp zoo_sample.cfg zoo.cfgcd /usr/local/zookeeper-3.4.6_3/confcp zoo_sample.cfg zoo.cfg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第五步：修改-zoo-cfg-配置文件"><a href="#第五步：修改-zoo-cfg-配置文件" class="headerlink" title="第五步：修改 zoo.cfg 配置文件"></a>第五步：修改 zoo.cfg 配置文件</h4><pre class="line-numbers language-none"><code class="language-none">cd /usr/local/zookeeper-3.4.6_1/conf# 设置内容如下：tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper-3.4.6_1/datadataLogDir=/usr/local/zookeeper-3.4.6_1/logsclientPort=2181server.1=127.0.0.1:2881:3881server.2=127.0.0.1:2882:3882server.3=127.0.0.1:2883:3883# -----------------------------------cd /usr/local/zookeeper-3.4.6_2/confvi zoo.cfg# 设置内容如下：tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper-3.4.6_2/datadataLogDir=/usr/local/zookeeper-3.4.6_2/logsclientPort=2182server.1=127.0.0.1:2881:3881server.2=127.0.0.1:2882:3882server.3=127.0.0.1:2883:3883# -----------------------------------cd /usr/local/zookeeper-3.4.6_3/confvi zoo.cfg# 设置内容如下：tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper-3.4.6_3/datadataLogDir=/usr/local/zookeeper-3.4.6_3/logsclientPort=2183server.1=127.0.0.1:2881:3881server.2=127.0.0.1:2882:3882server.3=127.0.0.1:2883:3883<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第六步：在dataDir-usr-local-zookeeper-3-4-6-x-data下创建-myid-文件"><a href="#第六步：在dataDir-usr-local-zookeeper-3-4-6-x-data下创建-myid-文件" class="headerlink" title="第六步：在dataDir=/usr/local/zookeeper-3.4.6_x/data下创建 myid 文件"></a>第六步：在dataDir=/usr/local/zookeeper-3.4.6_x/data下创建 myid 文件</h4><pre class="line-numbers language-none"><code class="language-none">vi /usr/local/zookeeper-3.4.6_1/data/myid #设置值为1vi /usr/local/zookeeper-3.4.6_2/data/myid #设置值为2vi /usr/local/zookeeper-3.4.6_3/data/myid #设置值为3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="第七步：启动并查看zookeeper"><a href="#第七步：启动并查看zookeeper" class="headerlink" title="第七步：启动并查看zookeeper"></a>第七步：启动并查看zookeeper</h4><pre class="line-numbers language-none"><code class="language-none">cd /usr/local/usr/local/zookeeper-3.4.6_1/bin/zkServer.sh start/usr/local/zookeeper-3.4.6_2/bin/zkServer.sh start/usr/local/zookeeper-3.4.6_3/bin/zkServer.sh start<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="第八步：验证zookeeper启动情况"><a href="#第八步：验证zookeeper启动情况" class="headerlink" title="第八步：验证zookeeper启动情况"></a>第八步：验证zookeeper启动情况</h4><pre class="line-numbers language-none"><code class="language-none">/usr/local/zookeeper-3.4.6_1/bin/zkServer.sh status/usr/local/zookeeper-3.4.6_2/bin/zkServer.sh status/usr/local/zookeeper-3.4.6_3/bin/zkServer.sh status<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="第九步：如果启动成功，三台机器结果类似如下-标红部分为一个leader-两个follower"><a href="#第九步：如果启动成功，三台机器结果类似如下-标红部分为一个leader-两个follower" class="headerlink" title="第九步：如果启动成功，三台机器结果类似如下,标红部分为一个leader,两个follower"></a>第九步：如果启动成功，三台机器结果类似如下,标红部分为一个leader,两个follower</h4><pre class="line-numbers language-none"><code class="language-none">[root@centos7 local]# /usr/local/zookeeper-3.4.6_1/bin/zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper-3.4.6_1/bin/../conf/zoo.cfgMode: "follower"[root@centos7 local]# /usr/local/zookeeper-3.4.6_2/bin/zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper-3.4.6_2/bin/../conf/zoo.cfgMode: "leader"[root@centos7 local]# /usr/local/zookeeper-3.4.6_3/bin/zkServer.sh statusJMX enabled by defaultUsing config: /usr/local/zookeeper-3.4.6_3/bin/../conf/zoo.cfgMode: "follower"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>此时zookeeper集群搭建成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;如近分布式架构常用到Zookeeper组建，下面来介绍下Zookeeper集群的搭建方法&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;第一步：下载并上传zookeeper-3-4-6-tar-gz到各个服务器的-usr-local-目录-或者使用wget命</summary>
      
    
    
    
    <category term="后端" scheme="https://raoys.github.io/categories/%E5%90%8E%E7%AB%AF/"/>
    
    
    <category term="Zookeeper" scheme="https://raoys.github.io/tags/Zookeeper/"/>
    
    <category term="集群" scheme="https://raoys.github.io/tags/%E9%9B%86%E7%BE%A4/"/>
    
  </entry>
  
  <entry>
    <title>Linux下如何释放cache内存(drop_caches)</title>
    <link href="https://raoys.github.io/2015/10/01/it-linux-03.html"/>
    <id>https://raoys.github.io/2015/10/01/it-linux-03.html</id>
    <published>2015-10-01T12:11:12.000Z</published>
    <updated>2025-01-14T03:16:09.138Z</updated>
    
    <content type="html"><![CDATA[<p><strong>最近使用的linux系统内存缓存越来越大，free内存越来越小，后来从网上找到资料完美解决。</strong> </p><h4 id="第1步：执行-cat-proc-sys-vm-drop-caches名称，查看缓存值，默认值为0。（1-清空页缓存；2-清空inode和目录树缓存；3-清空所有缓存）"><a href="#第1步：执行-cat-proc-sys-vm-drop-caches名称，查看缓存值，默认值为0。（1-清空页缓存；2-清空inode和目录树缓存；3-清空所有缓存）" class="headerlink" title="第1步：执行 cat /proc/sys/vm/drop_caches名称，查看缓存值，默认值为0。（1-清空页缓存；2-清空inode和目录树缓存；3-清空所有缓存）"></a>第1步：执行 cat /proc/sys/vm/drop_caches名称，查看缓存值，默认值为0。（1-清空页缓存；2-清空inode和目录树缓存；3-清空所有缓存）</h4><h4 id="第2步：执行sync命令，手动执行sync命令（描述：sync-命令运行-sync-子例程。如果必须停止系统，则运行-sync-命令以确保文件系统的完整性。sync-命令将所有未写的系统缓冲区写到磁盘中，包含已修改的-i-node、已延迟的块-I-O-和读写映射文件）"><a href="#第2步：执行sync命令，手动执行sync命令（描述：sync-命令运行-sync-子例程。如果必须停止系统，则运行-sync-命令以确保文件系统的完整性。sync-命令将所有未写的系统缓冲区写到磁盘中，包含已修改的-i-node、已延迟的块-I-O-和读写映射文件）" class="headerlink" title="第2步：执行sync命令，手动执行sync命令（描述：sync 命令运行 sync 子例程。如果必须停止系统，则运行 sync 命令以确保文件系统的完整性。sync 命令将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块 I/O 和读写映射文件）"></a>第2步：执行sync命令，手动执行sync命令（描述：sync 命令运行 sync 子例程。如果必须停止系统，则运行 sync 命令以确保文件系统的完整性。sync 命令将所有未写的系统缓冲区写到磁盘中，包含已修改的 i-node、已延迟的块 I/O 和读写映射文件）</h4><h4 id="第3步：执行echo-3-gt-gt-proc-sys-vm-drop-caches-命令，将drop-caches值改成3。"><a href="#第3步：执行echo-3-gt-gt-proc-sys-vm-drop-caches-命令，将drop-caches值改成3。" class="headerlink" title="第3步：执行echo 3 >> /proc/sys/vm/drop_caches 命令，将drop_caches值改成3。"></a>第3步：执行echo 3 &gt;&gt; /proc/sys/vm/drop_caches 命令，将drop_caches值改成3。</h4><p>此时已经完成，可执行 free -m 命令查看是否生效。</p><p><code>如图：</code><br><img src="/img/linux/2015-10-01-2011-linux-01.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;最近使用的linux系统内存缓存越来越大，free内存越来越小，后来从网上找到资料完美解决。&lt;/strong&gt; &lt;/p&gt;
&lt;h4 id=&quot;第1步：执行-cat-proc-sys-vm-drop-caches名称，查看缓存值，默认值为0。（1-清空页缓存；2-</summary>
      
    
    
    
    <category term="Linux" scheme="https://raoys.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://raoys.github.io/tags/Linux/"/>
    
  </entry>
  
</feed>
